import os, csv
import pymysql
from django.conf import settings
from django.http import HttpResponse
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from .models import Nodes
from docx import Document
from docx.shared import Inches
from .forms import UploadFileForm, UserForm
# -*- coding: utf-8 -*-

from _ast import For

def auth_login(request):
    return render(request, 'website/login.html')

def registration(request):
    return render (request, 'website/registration.html')

def register(request):
    form_class = UserForm
    if(request.method == "POST"):
        form = form_class(request.POST)
        if form.is_valid():

            user = form.save(commit=False)

            #cleaned normalized data
            username = form.cleaned_data['username']
            email = form.cleaned_data['email']
            password = form.cleaned_data['password']
            user.set_password(password)
            user.save()
            return redirect('/CiberC/')
    else:
        return render(request, 'website/login.html', {'error_message': "Registration Failed"})

def main(request):
    return render(request, 'website/main.html')

def login_validation(request):
    if(request.method == "POST"):
        #form = UserForm(request.POST)
        #if(form.is_valid()):
        username = request.POST['username']
        password = request.POST['password']
        email = request.POST['username']

        #return User object if credentials are correct
        user = authenticate(username=username, password=password)

        if user is not None:
            if user.is_active:
                login(request, user)
                return redirect('/CiberC/main/')
    return render(request, 'website/login.html', {'error_message': "Username or Password incorrect"})


def auth_logout(request):
    logout(request)
    return redirect('/CiberC/')


def upload(request):
    return render(request,'website/upload.html')


# handle_uploaded_file() -> Not a view
def handle_uploaded_file(file, filename):
    if not os.path.exists('file/'):
        os.mkdir('file/')

    with open('file/'+ filename, 'wb+') as destination:

        for chunk in file.chunks():
            destination.write(chunk)

def upload_file(request):
    if request.method == 'POST':
        handle_uploaded_file(request.FILES['file'], str(request.FILES['file']))
        #borrar()
        load_date('/var/www/html/CiberC/file/'+str(request.FILES['file']))
        return render(request, 'website/upload.html', {'success_message': "File uploaded"})
    return render(request, 'website/upload.html', {'error_message': "Error at uploading the File"})


def download(request):
    all_nodes = Nodes.objects.all()

    if os.path.exists('/var/www/html/CiberC/file/isistopology.txt'):
        return render(request, 'website/download.html', {'success_message': 'Please insert the name or ip addres of the node:'})

    if all_nodes.exists():
        return render(request, 'website/download.html', {'success_message': 'Please insert the name or ip addres of the node:'})
    return render(request, 'website/download.html', {'error_message': "No Data found. Please upload the isistopology.txt in the Upload section."})


def download_file(request):
    if (request.method == "POST"):
        nodo = request.POST['node']
        texto=conexas(nodo)
        print(texto)
	response = HttpResponse(content_type = 'text/plain')
    	response['Content-Disposition'] = 'attachment; filename="Report.txt"'
    	#writer = csv.writer(response)
    	#writer.writerow(texto)
    	response.write("EL nodo es :"+nodo)
	response.write(texto)


    return response

    return render(request, 'website/download.html', {'success_message': 'Please insert the name or ip addres of the node:'})


def view(request):
    all_nodes = Nodes.objects.all()

    if os.path.exists('/var/www/html/CiberC/file/isistopology.txt'):
        return render(request, 'website/view.html', {'success_message': 'Please insert the name or ip addres of the node:'})
    print(all_nodes)
    if all_nodes.exists():
        return render(request, 'website/view.html',
                      {'success_message': 'Please insert the name or ip addres of the node:'})
    return render(request, 'website/view.html', {'error_message': "No Data found. Please upload the isistopology.txt in the Upload section."})


def view_graph(request):
    if (request.method == "POST"):
        nodo = request.POST['node']
        level = request.POST['level']
        red = request.POST['red']
        link = request.POST['link']
        conn = pymysql.connect(
            host="localhost", port=3306, user="root",
            passwd="hotmail003", db="red"
        )
        print(level)
        print(link)
        texto = ""
        textono = ""
        nodo=convertir(nodo)

        try:
            list = []
            with conn.cursor() as cursor:
                sql0 = "SELECT * FROM `isis`"
                cursor.execute(sql0)
                for row in cursor:
                    nodo1 = row[0].rstrip("\r")
                    list.append(nodo1)

            with conn.cursor() as cursor:
                sql1 = "SELECT * FROM `isis` INNER JOIN provider USING(Hostname)"
                sql2 = "SELECT * FROM `isis` INNER JOIN provideredge USING(Hostname)"
                sql3 = "SELECT * FROM `isis` INNER JOIN border USING(Hostname)"
                sql = sql1 + " UNION " + sql2 + " UNION " + sql3 + " ORDER BY Hostname ASC"
                cursor.execute(sql)
                result=cursor.fetchall()
                listaT = []
                listaT.append(nodo)
                lista = []
                lista1 = []
                lista2 = []
                edge= []
                edge1= []
                for row in result:
                    nodo1=row[0].rstrip("\r")
                    lista.append(row)
                    palabras = row[2].split(".")
                    if level == "4":
                        palabras1 = palabras[0].split("-")
                        if (len(palabras1) >= 2):
                            if (palabras1[1] == "COR"):
                                palabras[0] = palabras[0] + "E"
                        if not palabras[0] in listaT:
                            lista1.append(palabras[0])
                            listaT.append(palabras[0])
                        if link == "1":
                            edgeT = "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(list.index(palabras[0])) + ", \"arrows\": \"to\" },\n"
                            edgeT1 = "{\"from\": " + str(list.index(palabras[0]))  + ", \"to\": " + str(list.index(nodo1))  + ", \"arrows\": \"to\" },\n"
                            if not edgeT in edge:
                                if not edgeT1 in edge:
                                    edge.append(edgeT)
                                    textono = textono + edgeT
                        else:
                            textono = textono + "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                            list.index(palabras[0])) + ", \"label\": \"" + str(row[4]) + "\", \"arrows\": \"to\" },\n"

                    else:
                        if nodo1==nodo:
                            palabras1 = palabras[0].split("-")
                            if (len(palabras1) >= 2):
                                if (palabras1[1] == "COR"):
                                    palabras[0] = palabras[0] + "E"

                            if level == "1" or level == "3" or level == "2":
                                if not palabras[0] in listaT:
                                    lista1.append(palabras[0])
                                    listaT.append(palabras[0])
                            if link == "1":
                                edgeT = "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) +", \"arrows\": \"to\" },\n"
                                edgeT1 = "{\"from\": " + str(list.index(palabras[0])) + ", \"to\": " + str(
                                    list.index(nodo1)) +", \"arrows\": \"to\" },\n"
                                if not edgeT in edge:
                                    if not edgeT1 in edge:
                                        edge.append(edgeT)
                                        textono = textono + edgeT
                            else:
                                textono = textono + "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) +", \"label\": \""+str(row[4])+"\", \"arrows\": \"to\" },\n"
                for k in lista:
                    nodo1 = k[0].rstrip("\r")
                    if nodo1 in lista1:
                        palabras = k[2].split(".")
                        palabras1 = palabras[0].split("-")
                        if (len(palabras1) >= 2):
                            if (palabras1[1] == "COR"):
                                palabras[0] = palabras[0] + "E"
                        if level == "3":
                            if not palabras[0] in listaT:
                                lista2.append(palabras[0])
                        if level=="4":
                            if not palabras[0] in listaT:
                                listaT.append(palabras[0])
                            if link == "1":
                                edgeT = "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) +", \"arrows\": \"to\" },\n"
                                edgeT1 = "{\"from\": " + str(list.index(palabras[0])) + ", \"to\": " + str(
                                    list.index(nodo1)) + ", \"arrows\": \"to\" },\n"
                                if not edgeT in edge:
                                    if not edgeT1 in edge:
                                        edge.append(edgeT)
                                        textono = textono + edgeT
                            else:
                                textono = textono + "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) + ", \"label\": \"" + str(k[4]) +"\", \"arrows\": \"to\" },\n"

                        if level == "3" or level == "2" :
                            if not palabras[0] in listaT:
                                listaT.append(palabras[0])
                            if link == "1":
                                edgeT = "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) + ", \"arrows\": \"to\" },\n"
                                edgeT1 = "{\"from\": " + str(list.index(palabras[0])) + ", \"to\": " + str(
                                    list.index(nodo1)) + ", \"arrows\": \"to\" },\n"
                                if not edgeT in edge:
                                    if not edgeT1 in edge:
                                        edge.append(edgeT)
                                        textono = textono + edgeT
                            else:
                                textono = textono + "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) + ", \"label\": \"" + str(k[4]) +"\", \"arrows\": \"to\" },\n"

                if level == "3":
                    for j in lista:
                        nodo1 = j[0].rstrip("\r")
                        if nodo1 in lista2:
                            palabras = j[2].split(".")
                            palabras1 = palabras[0].split("-")
                            if (len(palabras1) >= 2):
                                if (palabras1[1] == "COR"):
                                    palabras[0] = palabras[0] + "E"
                            if level == "3":
                                if not palabras[0] in listaT:
                                    listaT.append(palabras[0])
                            if link == "1":
                                edgeT = "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) + ", \"arrows\": \"to\" },\n"
                                edgeT1 = "{\"from\": " + str(list.index(palabras[0])) + ", \"to\": " + str(
                                    list.index(nodo1)) + ", \"arrows\": \"to\" },\n"
                                if not edgeT in edge:
                                    if not edgeT1 in edge:
                                        edge.append(edgeT)
                                        textono = textono + edgeT
                            else:
                                textono = textono + "{\"from\": " + str(list.index(nodo1)) + ", \"to\": " + str(
                                    list.index(palabras[0])) + ", \"label\": \"" + str(j[4]) + "\", \"arrows\": \"to\" },\n"

                for t in listaT:
                    if t[-3] == "P":
                        Tipo = "P"
                    if t[-3] == "E":
                        Tipo = "E"
                    if t[-3] == "R":
                        Tipo = "R"
                    if t[-3] == "B":
                        Tipo = "B"
                    if t == nodo:
                        Tipo = "C"
                    if t in list:
                        texto = texto + "{id:" + str(list.index(t)) + ", \"label\": \"" + t + "\", \"group\": \"" + Tipo + "\"},\n"
        finally:
            # Close connection.
            conn.close()
        if red=="1":
            return render(request, 'website/GrafoR.html', {'nodos': texto, 'edge': textono})
        else :
            return render(request, 'website/Grafo.html', {'nodos': texto,'edge': textono})

def load_date(documento):
    conn = pymysql.connect(
        host="localhost", port=3306, user="root",
        passwd="hotmail003", db="red"
    )
    fileShow = open(documento, "r")
    lineas = fileShow.readlines()
    acum3 = 0;
    hostname = []
    ip = []
    ipGlobal = []
    metric = []
    extended = []
    vecinosGlobal = []
    metricGlobal = []
    extendedGlobal = []
    vecinos = []
    for i in lineas:
        palabras = i.split(" ")
        if palabras[0] == "Connection":
            vecinosGlobal.append(vecinos)
            metricGlobal.append(metric)
            extendedGlobal.append(extended)
            if (ip):
                ipGlobal.append(ip)
            else:
                ip.append("0")
                ipGlobal.append(ip)
            ip = []
            vecinos = []
            metric = []
            extended = []
        if len(palabras) >= 3:
            if palabras[2] == "Hostname:":
                if acum3 == 1:
                    vecinos.append("0")
                    acum3 = 0
                palabras1 = palabras[3].split("\n")
                hostname.append(palabras1[0])
                if len(hostname) == 1:
                    vecinos = []
                    metric = []
                    extended = []
                    ip = []
                else:
                    vecinosGlobal.append(vecinos)
                    metricGlobal.append(metric)
                    extendedGlobal.append(extended)
                    if (ip):
                        ipGlobal.append(ip)
                    else:
                        ip.append("0")
                        ipGlobal.append(ip)
                    ip = []
                    vecinos = []
                    metric = []
                    extended = []
        if len(palabras) >= 5:
            if palabras[2] == "IP" and palabras[3] == "Address:":
                palabras1 = palabras[-1].split("\n")
                ip.append(palabras1[0])
            if palabras[4] == "Neighbor":
                palabras1 = palabras[-1].split("\n")
                vecinos.append(palabras1[0])
                acum3 = 0
            if acum3 == 1:
                vecinos.append("0")
                acum3 = 0
            if palabras[2] == "Metric:":
                acum3 = 1
                metric.append(palabras[3])
                palabras1 = palabras[-1].split("\n")
                extended.append(palabras1[0])

    acum = 0;
    try:
        sql = "DELETE FROM `border` "
        sql1 = "DELETE FROM `provider` "
        sql2 = "DELETE FROM `provideredge` "
        sql3 = "DELETE FROM `isis`"
        with conn.cursor() as cursor:
            cursor.execute(sql)
            conn.commit()
            cursor.execute(sql1)
            conn.commit()
            cursor.execute(sql2)
            conn.commit()
        with conn.cursor() as cursor:
            cursor.execute(sql3)
            conn.commit()
        for i in hostname:
            sql = "INSERT INTO `isis`( `Hostname`, `Ip`) VALUES ('" + hostname[acum] + "','" + ipGlobal[acum][0] + "') "
            for m in ipGlobal[acum]:
                if not m==ipGlobal[acum][0]:
                    sql1 = "INSERT INTO `Ip`( `Hostname`, `Ip`) VALUES ('" + hostname[acum] + "','" + m + "') "
                    with conn.cursor() as cursor:
                        cursor.execute(sql1)
                        conn.commit()
            print(acum)
            with conn.cursor() as cursor:
                 cursor.execute(sql)
                 conn.commit()
            acum1 = 0;
            with conn.cursor() as cursor:
                for j in extendedGlobal[acum]:
                    palabras1 = extendedGlobal[acum][acum1].split(".")
                    cadena = list(palabras1[0])

                    if not cadena[1] == "-":
                        palabras2 = palabras1[0].split("-")
                        cadena1 = list(palabras2[0])
                    else:
                        palabras2 = palabras1[0]
                        cadena1 = list(palabras2)

                    if cadena1[-3] == "P":
                        sql = "INSERT INTO `provider`( `Hostname`, `Neighbor`, `Ip`, `Metrica`) VALUES ('" + hostname[
                            acum] + "','" + extendedGlobal[acum][acum1] + "','" + vecinosGlobal[acum][acum1] + "','" + \
                              metricGlobal[acum][acum1] + "') "
                    if cadena1[-3] == "E":
                        sql = "INSERT INTO `provideredge`( `Hostname`, `Neighbor`, `Ip`, `Metrica`) VALUES ('" + \
                              hostname[acum] + "','" + extendedGlobal[acum][acum1] + "','" + vecinosGlobal[acum][
                                  acum1] + "','" + metricGlobal[acum][acum1] + "') "
                    if cadena1[-3] == "B":
                        sql = "INSERT INTO `border`( `Hostname`, `Neighbor`, `Ip`, `Metrica`) VALUES ('" + hostname[
                            acum] + "','" + extendedGlobal[acum][acum1] + "','" + vecinosGlobal[acum][acum1] + "','" + \
                              metricGlobal[acum][acum1] + "') "
                    if cadena1[-3] == "R":
                        sql = "INSERT INTO `border`( `Hostname`, `Neighbor`, `Ip`, `Metrica`) VALUES ('" + hostname[
                            acum] + "','" + extendedGlobal[acum][acum1] + "','" + vecinosGlobal[acum][acum1] + "','" + \
                              metricGlobal[acum][acum1] + "')"
                    cursor.execute(sql)
                    acum1 = acum1 + 1
                    conn.commit()
            acum = acum + 1
    finally:
        # Close connection.
        conn.close()
    fileShow.close()

def convertir(nodo):
        conn = pymysql.connect(
            host="localhost", port=3306, user="root",
            passwd="hotmail003", db="red"
        )
        nod = nodo.split(".")
        bandera=0
        if (nod >= 2):
            bandera=1
        try:
            with conn.cursor() as cursor:
                sql0 = "SELECT * FROM `isis`"
                cursor.execute(sql0)
                for row in cursor:
                    nodo1 = row[0].rstrip("\r")
                    nodo2 = row[1].rstrip("\r")
                    if nodo2 == nodo:
                        bandera = 0
                        nodo = nodo1

            if bandera==1:
                with conn.cursor() as cursor:
                    sql0 = "SELECT * FROM `Ip`"
                    cursor.execute(sql0)
                    for row in cursor:
                        nodo2 = row[1].rstrip("\r")
                        if nodo2 == nodo:
                            nodo1 = row[0].rstrip("\r")
                            bandera = 0
                            nodo = nodo1
            if bandera==1:
                with conn.cursor() as cursor:
                    sql1 = "SELECT * FROM `isis` INNER JOIN provider USING(Hostname)"
                    sql2 = "SELECT * FROM `isis` INNER JOIN provideredge USING(Hostname)"
                    sql3 = "SELECT * FROM `isis` INNER JOIN border USING(Hostname)"
                    sql = sql1 + " UNION " + sql2 + " UNION " + sql3 + " ORDER BY Hostname ASC"
                    cursor.execute(sql)
                    for row in cursor:
                        nodo2 = row[3].rstrip("\r")
                        if nodo2 == nodo:
                            nodo1 = row[2].rstrip("\r")
                            nod2 = nodo1.split(".")
                            bandera = 0
                            nodo = nod2[0]
        finally:
            # Close connection.
            conn.close()
        return nodo

def connected_components(nodes, diccionario):
    # List of connected components found. The order is random.
    result = []

    # Make a copy of the set, so we can modify it.
    nodes = set(nodes)

    # Iterate while we still have nodes to process.
    while nodes:

        # Get a random node and remove it from the global set.
        n = nodes.pop()

        # This set will contain the next group of nodes connected to each other.
        group = {n}

        # Build a queue with this node in it.
        queue = [n]

        # Iterate the queue.
        # When it's empty, we finished visiting a group of connected nodes.
        while queue:
            # Consume the next item from the queue.
            n = queue.pop(0)
            # Fetch the neighbors.

            neighbors = diccionario.get(n)

            if neighbors==None:
                break
            if len(neighbors)>0:
                # Remove the neighbors we already visited.
                neighbors.difference_update(group)

                # Remove the remaining nodes from the global set.
                nodes.difference_update(neighbors)

                # Add them to the group of connected nodes.
                group.update(neighbors)
                #print(group)
                # Add them to the queue, so we visit them in the next iterations.
                queue.extend(neighbors)

        # Add the group to the list of groups.
        result.append(group)
    # Return the list of groups.

    return result

def conexas(nodo):
    conn = pymysql.connect(
        host="localhost", port=3306, user="root",
        passwd="hotmail003", db="red"
    )
    nodo=convertir(nodo)
    print(nodo)
    try:
        nodes = set()
        list = []
        with conn.cursor() as cursor:
            sql0 = "SELECT * FROM `isis`"
            cursor.execute(sql0)
            for row in cursor:
                nodo1 = row[0].rstrip("\r")
                list.append(nodo1)

        with conn.cursor() as cursor:
            sql1 = "SELECT * FROM `isis` INNER JOIN provider USING(Hostname)"
            sql2 = "SELECT * FROM `isis` INNER JOIN provideredge USING(Hostname)"
            sql3 = "SELECT * FROM `isis` INNER JOIN border USING(Hostname)"
            sql = sql1 + " UNION " + sql2 + " UNION " + sql3 + " ORDER BY Hostname ASC"
            cursor.execute(sql)
            result = cursor.fetchall()
            lista = []
            lista1 = []
            diccionario = dict()
            listaT = []
            listaT.append(nodo)
            for row in result:
                nodo1 = row[0].rstrip("\r")
                lista.append(row)
                palabras = row[2].split(".")
                palabras1 = palabras[0].split("-")
                if (len(palabras1) >= 2):
                    if (palabras1[1] == "COR"):
                        palabras[0] = palabras[0] + "E"
                        lista1.append(palabras[0])
                if not palabras[0] in listaT:
                    listaT.append(palabras[0])
                if str(nodo1) != nodo and str(palabras[0]) != nodo:
                    listaVal = set()
                    if str(nodo1) in diccionario:

                        for x in diccionario.get(str(nodo1)):
                            if not x in listaVal:
                                listaVal.add(x)
                        listaVal.add(str(palabras[0]))
                        diccionario[str(nodo1)] = listaVal
                    else:
                        listaVal.add(str(palabras[0]))
                        diccionario[str(nodo1)] = listaVal
                for k in lista:
                    nodo1 = k[0].rstrip("\r")
                    listaVal = set()
                    if nodo1 in lista1:
                        palabras = k[2].split(".")
                        palabras1 = palabras[0].split("-")
                        if (len(palabras1) >= 2):
                            if (palabras1[1] == "COR"):
                                palabras[0] = palabras[0] + "E"
                        if not palabras[0] in listaT:
                            listaT.append(palabras[0])
                        if str(nodo1) != nodo and str(palabras[0]) != nodo:
                            if str(nodo1) in diccionario:
                                for x in diccionario.get(str(nodo1)):
                                    if not x in listaVal:
                                        listaVal.add(x)
                                listaVal.add(str(palabras[0]))
                                diccionario[str(nodo1)] = listaVal
                            else:
                                listaVal.add(str(palabras[0]))
                                diccionario[str(nodo1)] = listaVal
            for t in listaT:
                if t in list:
                    if not t == nodo:
                        nodes.add(t)
            number=1
	    grupo="<p>El nodo seleccionado es: " +nodo +"</p>"
	    grupo=grupo +"<p>Se a creado los siguientes grupos: "+"</p>"

   	    for components in connected_components(nodes, diccionario):
            	grupo=grupo +"<p>Group #%i: %s" % (number, components)+"</p>"
            	number += 1
            return  grupo
    finally:
        # Close connection.
        conn.close()





